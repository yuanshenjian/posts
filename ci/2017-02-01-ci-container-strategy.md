---
layout: post
title: "持续集成的容器化策略"
date: 2017-02-01
categories: [CI]
tags: [Continuous Integration]
author: "袁慎建"

brief: "在传统的交付过程中，开发人员和测试人员在开发测试的时候，所有的功能都正确无误，但部署到生产环境后，莫名其妙的问题就来了，这是因为开发、测试和生产环境都存在差异性，系统环境引发的问题。除此之外，生产环境通常会存在多个，而每部署一个新的环境意味着需要解决系统环境的差异性引发的问题，造成了无畏的浪费。</br></br>

Docker容器的诞生，使得开发测试时的环境可以直接部署到生产环境上，有效地屏蔽了环境的差异性，解决了这个问题。本文介绍一种以Docker为载体的容器化持续集成策略。"

---

* content
{:toc}

---


## 何为容器

>近两年，随着`容器`（以 [Docker](https://www.docker.com/) 为首）的兴起，解决了诸多传统交付过程中的问题，像`一次构建，随处运行`以及`开发即生产`这些传为佳话。

在传统的交付过程中，开发人员和测试人员在开发测试的时候，所有的功能都正确无误，但部署到生产环境后，莫名其妙的问题就来了，这是因为开发、测试和生产环境都存在差异性，系统环境引发的问题。除此之外，生产环境通常会存在多个，而每部署一个新的环境意味着需要解决系统环境的差异性引发的问题，造成了无畏的浪费。

Docker容器的诞生，使得开发测试时的环境可以直接部署到生产环境上，有效地屏蔽了环境的差异性，解决了这个问题。它将软件运行所需的所有环境（系统参数、基础工具和第三方服务等）都封装在一个容器内部，任何需要部署的地方，只需要将容器运行起来。容器可以很方便地运行在Linux内核上。

用两张图来概括容器诞生前后的部署方式：

![]({{ site.url }}{{ site.img_path }}{{ '/dojo/ci/deployment-without-container.png' }})

图中可见，部署一个Application通常需要诸多环境，所以每次部署的不同的Server的时候都需要执行安装脚本，一方面安装需要消耗网络资源和大量时间，另一方面，因为不同Server的环境问题，可能某些步骤不会那么顺利。都增加了部署成本。

使用容器后，部署方式就变了：

![]({{ site.url }}{{ site.img_path }}{{ '/dojo/ci/deployment-with-container.png' }})

我们会将所有的依赖和服务打包安装好，只需要将打包好的Image部署到相应的Server，而对Server的要求就是安装好 [Docker](https://www.docker.com/) 命令行工具，然后使用docker运行容器即可。

>实践指导：
>实际部署中，我们通常按照单个服务的粒度进行划分容器，并不会将类似`Postgres Server`和`Application`这样的两个服务放在一个容器中，而是将它们放在不同的容器中，并通过容器互联的方式进行交互。

所以，一句话概括容器所做的事情：`提供轻量且安全、独立且隔离的运行环境`

---

## 容器化部署

如此便捷，为何不在CI上使用容器化方案呢？我们之前的一个Python项目就使用了这种方案，CI服务的启动、测试运行、打包、部署，都是基于Docker容器完成的。我们的CI Pipeline如下图：

![]({{ site.url }}{{ site.img_path }}{{ '/dojo/ci/pipeline-with-container.png' }})

Pipeline中有五个步骤：

```
1. Portal，CI的入口，pull代码，编译，构建镜像（容器的载体）。
2. 单元测试，使用 $ docker run ...在容器中运行单元测试。
3. 集成测试，使用 $ docker run ...在容器中运行集成测试。
4. E2E测试，使用 $ docker run ...在容器中运行E2E测试。
6. 部署，测试通过后，将Portal中编译好的镜像部署到目标环境中。
```

细心的读者可能已经发现了一个问题，这没有打包过程，因为Python语言术语解释型语言，通常直接源码部署。但另外一个问题来了，如果部署的步骤直接部署了Portal中的镜像，是不是会将测试代码都打包了？

漂亮，这绝对是个好问题，以下列出了一些解决方案：

```
1. 构建镜像的时候不将测试代码添加进去，而在测试步骤，运行容器时将测试目录挂载到容器中。
2. 部署的时候重新使用Portal的代码库构建一个不包含测试代码的镜像进行部署。
3. 将代码库中部署到目标环境，在目标环境中构建镜像并运行容器。
```
每种方案，各有千秋，我个人推荐的是第二种，理由此处不详叙。

---

## 容器的管理
一个Web项目，通常会有应用、数据库、缓存等服务，而容器化方案推崇一个容器运行一个服务，通过容器互联的方式，将它们联结在一起构成一个可用的系统。所以，在部署的时候，我们通常会部署多个镜像，简单的比如单应用：主应用*1 + 数据库\*1，复杂的比如微服务模式： 负载均衡\*1 + 主应用模块\*n + 数据库\*n + 缓存\*n + ...，如何去管理这些容器的生命周期，这就是目前微服务系统架构师所面临的挑战，再者，包括如何定义和拆分服务、如何实现服务发现、如何保证安全性、如何实现服务高可靠性（99%）、如何实现热部署等。

[Docker](https://www.docker.com/) 官方提供了容器编排的命令行工具 [Docker compose](https://docs.docker.com/compose/) 和集群管理工具 [swarm](https://www.docker.com/products/docker-swarm) ，我们用它可以管理多个容器的互联，另外， [Docker rancher](http://rancher.com/) 提供了一个高效的可视化的管理方案。[Docker Hub](https://hub.docker.com/) 也提供了容器部署和管理一体化方案，它还可以跟AWS进行集成。

---

## 面临的挑战
容器化带来便利的同时也带来了诸多挑战。`如何定义服务？`、`如何区分服务边界？`、`如何实现服务发现？`、`如何做到服务高可靠？`、`如何管理大量运行的容器？`、`如何管理容器的分发？`等等。幸运的是，这些挑战给行业注入了巨大的能量，始终存在一批技术先驱和实践王者走在前面，去攻克一个个问题，从而造就行业的革命。


---

## 相关阅读
[Docker三年回顾：梦想依在，人生正当年](http://www.infoq.com/cn/articles/docker-turns-3)
[Docker会是改变世界的那只“箱子”吗？](http://www.infoq.com/cn/articles/will-docker-be-the-box-that-change-the-world)



版权印为您的作品印上版权93399311








