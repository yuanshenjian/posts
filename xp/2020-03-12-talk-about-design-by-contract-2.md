---
layout: "post"
title: "简单聊聊契约设计（下）"
date: 2020-03-12
categories: [eXtreme Programming]
tag: [eXtreme Programming, DBC]

author: "袁慎建"

---

* content
{:toc}

---


<!--brief-->

在上一篇文章中，我们通过Bob大叔在讲解LSP的案例，我们在做模型设计的时候，要基于客户程序使用的角度去审视模型的有效性，这就需要我们要去猜测客户程序的一些"合理"的假设。当一个事情需要靠猜测的时候，我们总会觉得心里不安。Bob大叔提到了DBC这项技术，能够来帮助我们来明确用户的合理假设。

<!--brief-->

## DBC提倡的是一种契约精神
> 契约是指"依照法律订立的正式的证明.出卖.抵押.租赁等关系的文书"。 -- 《现代汉语词典》

契约这个东西，我们祖先在很久前就发明出来了。古代以物易物，我用2斤大米跟你环1斤黄豆，我今天帮你干半天活，你明天帮我干半天活。再到后来，发明了货币制度，用货币去购买物品，背后其实体现的也是一种契约精神。

由于上述的交易很快完成了，就不需要正式的合同文书。而对于那些具有后续持续义务的交易，比如按揭买房，我们需要通过一些法律的保障来加强强化彼此契约精神，所以就有了后来各种协议和合同，并受到了法律的保护。

契约明确地规定了双方需要履行的职责，以及可以各自可以享受的权益。在现实生活中的房产交易，有了购房合同，只要彼此履行契约规则，互相不需要去猜测对方会不会变卦，因为变卦后会受到法律保护。

但在软件设计中，就没有这么幸运了，你设计的API接口，如果使用者不按照你的要求使用，或者使用者按照你的规则来使用，却产生了意外的结果，这对彼此都不是一件值得高兴的事情。那在软件设计中，我们是否也可以引入契约精神，来减少这种没必要的"纠纷"呢？



![]({{site.image_path_post}}{{page.url}}{{'dbc.png'}})

## 买房子的契约
派生类的前置条件和后置条件满足一下规则：

1. 只能使用相等或更弱的前置条件
2. 只能使用相等或更强的后置条件

用户通过基类使用独对象时，用户只知道基类的前置条件和后置条件，因此派生类不能要求客户遵循比基类更强的前置条件，他们必须接受基类可接受的一切，派生类必须和基类的后置条件一致，也就是说，派生类的行为方式和输出不能违反基类已经确立的任何限制，基类的用户不应该被派生类的输出扰乱。



`Rectangle.setWidth(double width)`：

- 前置条件是：`type width is double`
- 后置条件是：`this.width == width && this.height = old.height`


`Square.setWidth(double width)`：

- 前置条件是：`type width is double`
- 后置条件是：`this.width == width && this.height = width`


派生类的前置条件没有比之前更严格，但后置条件破坏了原有的限制。这种设计就破坏契约了。


这就好比你在买房，房产销售顾问小吴跟你签了个协议，协议里对你的约定：

1. 3.15号之前缴纳剩余100万首付款
2. 支付宝、储蓄卡或者现金

合同里对房产商的约定：

1. 3.15号之前房源被锁定，不再对外销售：
2. 提供24小时私人订制服务。

后来小吴因为有事情休假了，让小高代替服务你，这时候如果他要求做了以下几件事情：

1. 要求你3.13要缴纳剩余100首付款。
2. 只能付现金或刷储蓄卡。

3. 3.13号将房源对外公布购买。
4. 下午8 ~ 10点打电话关机。

如果小吴看成父类，小高看成子类，提供服务相当于小吴提供的方法，小高继承了小吴后：

- 方法的前置条件更加严格了：1，2相当于协议的前置条件更强了；
- 方法后置条件被破坏了：3，4相当于协议的后置条件被破坏了

用户如果以跟小吴合作的方式，上述的事情发生后，用户这边肯定遭遇很多意想不到的意外结果，这时候作为用户的你，肯定会不乐意了。






