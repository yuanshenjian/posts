---
layout: "post"
title: "简单聊聊契约设计（下）"
date: 2020-03-12
categories: [eXtreme Programming]
tag: [eXtreme Programming, DBC]
toXPSite: true
author: "袁慎建"

---

* content
{:toc}

---


<!--brief-->
在上一篇文章中，我们从Bob大叔讲解的LSP中得出了一个结论 -- 做模型设计的时候，要基于客户程序使用的角度去审视模型的有效性。这就需要我们要去猜测客户程序的一些"合理"的假设。当一个事情需要靠猜测的时候，我们总会觉得心里不安。Bob大叔提到`DbC`这项技术，能够帮助我们来明确用户的合理假设。本文就来聊聊DbC。
<!--brief-->

## 契约促进社会秩序稳定
> 契约是指"依照法律订立的正式的证明.出卖.抵押.租赁等关系的文书"。 -- 《现代汉语词典》

很久前，我们的祖先就发明了契约。古代以物易物，我用2斤大米跟你环1斤黄豆，我今天帮你干半天活，你明天帮我干半天活。再到后来，发明了货币制度，用货币去购买物品，背后其实体现的也是一种契约精神。

由于上述的交易很快完成，不需要正式的合同文书。对于那些具有持续义务的交易，比如按揭买房，就需要通法律的保障来强化契约，所以就有了后来"加盖公章"协议和合同。

契约明确地规定了双方履行的职责，以及各自享受的权益。在现实生活中的房产交易，一旦有一方变卦违约了，另一方就会受到法律保护。但在软件设计中，就没有这么幸运了，你设计的API接口，如果使用者不按照你的要求使用，或者使用者按照你的规则来使用，却产生了意外的结果，这对彼此都不是一件值得高兴的事情。

那在软件设计中，我们是否也可以引入契约精神，来减少这种没必要的"纠纷"呢？当然可以，已经有人这么干了。


## DbC体现了一种契约精神
早在1986年，伯特兰·迈耶就提了出**Design by Contract**[1]，这哥们还设计了Eiffel编程语言来实现这种设计思想。2003年，由伯特兰·迈耶创建的Eiffel Software公司申请将**Design by Contract**作为商标，并于2004年12月获得授权。


**Design by Contract**，按契约设计，也叫契约编程，它规定软件设计人员应为软件组件定义正式、精确和可验证的接口规范，该规范应使用**前提条件**、**后置条件**和**不变式**来扩展抽象数据类型的普通定义。根据对商业合同的条件和义务的概念隐喻，这些规范被称为`合同`，在本文中我称之为契约。


{% include post-image.html name = 'dbc.png' reference='https://en.wikipedia.org/wiki/Design_by_contract' %}


DbC应用了霍尔逻辑[2]，霍尔逻辑中的霍尔三元组清晰定义了：

> {P} C {Q}

P和Q是**断言**，C是**命令** 。P叫做**前置条件**，Q叫做**后置条件**。霍尔三元组简单理解为：只要P在C执行前的状态下成立，则在执行之后Q也成立。


## DbC在OOD中的应用
结合DbC的描述，我们来看看，上文中提到的Rectangle和Square，`Rectangle.setWidth(double width)`

- 前置条件是：assert type width is double
- 后置条件是：assert this.width == new.width && this.height = old.height


而`Square.setWidth(double width)`：

- 前置条件是：assert type width is double
- 后置条件是：assert this.width == new.width && this.height = new.width

同理，setHeight的方法也是如此。

从上述的分析来看，派生类Square的前置条件跟基类Rectangle保持一致，后置条件发生了变化，那么对于以下方法：

```java
private static void assertStandardHouseArea(Rectangle rectangle) {
    rectangle.setHeight(20);
    rectangle.setWidth(30);
    assert rectangle.calculateArea() == 600;
}
```

- 前置条件：assert input is a Rectangle
- 后置条件：assert rectangle.calculateArea() == 600

假如使用者传入了一个Square实例，因为Square is a Rectangle，前置条件没有变，但后置条件变了`assert rectangle.calculateArea() == 900`，该方法违背了DbC。这种现象的发生很可能会让使用者心寒 -- 一个"遵纪守法"的公民受到了不公的对待。

究其原因，归根结底是因为Square继承了Rectangle之后，违反了Rectangle定下的契约。那么，回到OOD中，按照伯特兰·迈耶的DbC的描述，相比于基类，派生类应该遵守的契约是：

1. 派生类只能使用相等或更宽松的前置条件。
2. 派生类只能使用相等或者更严格的后置条件。


为了更好地理解这两条契约规则，我们来看一个生活中的故事。


## 房屋买卖的合同契约

比如，你正在买房，房产销售顾问小吴跟你签了个协议，并加盖了公章，协议里对你的约束：

1. 3.15号之前缴纳剩余100万首付款
2. 支付方式可以是支付宝、储蓄卡或者现金

合同里，房产商需要履行的职责：

1. 3.15号之前房源被锁定，不再对外销售：
2. 提供24小时热线服务。

后来小吴因为有事情休假了，让小高来服务你，这时候如果他中途告诉你：

1. 3.13号之前要缴纳剩余100万首付款。
2. 只能付现金或刷储蓄卡。

在后期的协作中，你得知了如下实情：

1. 3.13号就将房源对外公布购买。
2. 下午8 ~ 10点销售电话一直关机。

所以，在整个过程中，你跟房产商的契约其实发生了变化：

- 前置条件更加严格：对你的要求更为苛刻。
- 后置条件更加宽松：服务承诺和服务质量下降。

作为客户，你遵守了跟小吴一起建立的契约，但是小高破坏了这个契约，后面你跟销售顾问这边的摩擦就在所难免了，如果不能及时协商调解，很有可能引发跟房产商的法律纠纷。

通过这个例子来看上述两条规则：

1. 派生类只能使用相等或更宽松的前置条件
	- 小高可以让你的支付日期在3.15或者之后
	- 小高可以提供以上三种或者更多的的支付方式
2. 派生类只能使用相等或者更严格的后置条件
	- 小高可以保证为你锁定房源到3.15号或者更久
	- 小高可以提供24小时热线服务（好像也不能更严格了）


## DbC为我们指明了一个方向
回到我们最初在谈LSP这个设计原则的一个问题 -- `如何有效地帮助明确用户合理的假设？`，客户程序基于父类行为方式的合理假设，断定子类能够替换掉父类，且行为方式保持一致。**Design by Contract**设计思想的提出，为我们猜测客户程序的合理假设提供一个依据，从而指导设计出遵循LSP的继承体系。虽然在程序设计领域，违背了契约，不会受到法律的制裁，但会付出额外的开发成本，重则导致客户丢失市场份额。

我相信大部分在一线写代码的程序员听说过**约定由于配置**。简单来讲，当没有形成一个大家共识且自发遵守的东西（约定）时，我们需要借助附加的流程来进行管控（配置）。渐渐地，当大家心中形成了共识，便不再依赖这些配置。

所以，如果你不知道什么样的代码是规范的代码，可以考虑借助一些显性的参考依据，比如代码规范文档。而伯特兰·迈耶提出的**Design by Contract**实际上也是在为我们提供一个这样的参考，帮助程序设计走向一个更好、更优的状态。


## 参考阅读
1. [契约式设计](https://en.wikipedia.org/wiki/Design_by_contract)
2. [霍尔逻辑](https://en.wikipedia.org/wiki/Hoare_logic)
3. [面向对象软件建构](https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction)




